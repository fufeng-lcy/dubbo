1、: 构建源码调试环境
    dubbo源码官方地址: https://github.com/apache/dubbo
        1、fork 官方dubbo仓库到自己的仓库
        2、git clone git@github.com:[自己仓库名称]/dubbo.git
        3、到当前clone的目录(含有pom.xml)中，执行mvn clean install -Dmaven.test.skip=true
        4、将项目转换成idea项目 mvn idea:idea(如果需要失败可以利用 mvn idea:workspace)
        5、切换分支到目前主流分支
            git fetch   拉去所有相关的远程仓储到本地仓储
            git checkout -b 2.7.8-release  切换到release分支
2、: 项目结构概览
    dubbo-common :  Dubbo 的一个公共模块，其中有很多工具类以及公共逻辑，例如 Dubbo SPI 实现、时间轮实现、动态编译器等。
        org.apache.dubbo.common.compiler : 动态编译相关
        org.apache.dubbo.common.config : 配置相关
        org.apache.dubbo.common.constants : 通用常量定义(如url参数的key)
        org.apache.dubbo.common.convert : 类型转换器
        org.apache.dubbo.common.extension : SPI 核心实现
        org.apache.dubbo.common.io : IO相关实现类
        org.apache.dubbo.common.logger : 多种java日志集成
        org.apache.dubbo.common.threadlocal : ThreadLocal相关工具类
        org.apache.dubbo.common.threadpool : 线程池相关工具类
        org.apache.dubbo.common.timer : 时间轮训器工具
        org.apache.dubbo.common.utils : 通用工具类
    dubbo-remoting : Dubbo 的远程通信模块，其中的子模块依赖各种开源组件实现远程通信。
        在 dubbo-remoting-api 子模块中定义该模块的抽象概念，在其他子模块中依赖其他开源组件进行实现，
        例如:
            dubbo-remoting-netty4 子模块依赖 Netty 4 实现远程通信，
            dubbo-remoting-etcd3 子模块依赖 etcd 3 实现远程通信，
            dubbo-remoting-p2p 子模块依赖 p2p 实现远程通信，
            dubbo-remoting-redis 子模块依赖 redis 实现远程通信，
            dubbo-remoting-zookeeper 通过 Apache Curator 实现与 ZooKeeper 集群的交互。
    dubbo-rpc : Dubbo 中对远程调用协议进行抽象的模块，其中抽象了各种协议，依赖于 dubbo-remoting 模块的远程调用功能。
        dubbo-rpc-api 子模块是核心抽象，其他子模块是针对具体协议的实现。
        例如:
            dubbo-rpc-dubbo 子模块是对 Dubbo 协议的实现，依赖了 dubbo-remoting-netty4 等 dubbo-remoting 子模块。
            dubbo-rpc 模块的实现中只包含一对一的调用，不关心集群的相关内容。
    dubbo-cluster :  Dubbo 中负责管理集群的模块，提供了负载均衡、容错、路由等一系列集群相关的功能，
        最终的目的是将多个 Provider 伪装为一个 Provider，这样 Consumer 就可以像调用一个 Provider 那样调用 Provider 集群了。
    dubbo-registry : Dubbo 中负责与多种开源注册中心进行交互的模块，提供注册中心的能力。
        其中， dubbo-registry-api 子模块是顶层抽象，其他子模块是针对具体开源注册中心组件的具体实现，
        例如，dubbo-registry-zookeeper 子模块是 Dubbo 接入 ZooKeeper 的具体实现。
    dubbo-monitor : Dubbo 的监控模块，主要用于统计服务调用次数、调用时间以及实现调用链跟踪的服务。
    dubbo-config :  Dubbo 对外暴露的配置都是由该模块进行解析的。
        例如:
        dubbo-config-api 子模块负责处理 API 方式使用时的相关配置
        dubbo-config-spring 子模块负责处理与 Spring 集成使用时的相关配置方式。
        有了 dubbo-config 模块，用户只需要了解 Dubbo 配置的规则即可，无须了解 Dubbo 内部的细节。
    dubbo-metadata : Dubbo 的元数据模块。
        dubbo-metadata 模块的实现套路也是有一个 api 子模块进行抽象，然后其他子模块进行具体实现。
    dubbo-configcenter : Dubbo 的动态配置模块，主要负责外部化配置以及服务治理规则的存储与通知，提供了多个子模块用来接入多种开源的服务发现组件。

3、: 解析Dubbo配置总线 URL（Uniform Resource Locator，统一资源定位符）
    URL 本质上就是一个特殊格式的字符串。一个标准的 URL 格式可以包含如下的几个部分：
        protocol://username:password@host:port/path?key=value&key=value
        1、 protocol：URL 的协议。我们常见的就是 HTTP 协议和 HTTPS 协议，当然，还有其他协议，如 FTP 协议、SMTP 协议等。
        2、username/password：用户名/密码。 HTTP Basic Authentication 中多会使用在 URL 的协议之后直接携带用户名和密码的方式。
        3、host/port：主机/端口。在实践中一般会使用域名，而不是使用具体的 host 和 port。
        4、path：请求的路径。
        5、parameters：参数键值对。一般在 GET 请求中会将参数放到 URL 中，POST 请求会将参数放到请求体中。

    Dubbo中的URL : dubbo://192.168.32.91:20880/org.apache.dubbo.demo.DemoService?anyhost=true&application=dubbo-demo-api-provider&dubbo=2.0.2&interface=org.apache.dubbo.demo.DemoService&methods=sayHello,sayHelloAsync&pid=32508&release=&side=provider&timestamp=1593253404714dubbo://172.17.32.91:20880/org.apache.dubbo.demo.DemoService?anyhost=true&application=dubbo-demo-api-provider&dubbo=2.0.2&interface=org.apache.dubbo.demo.DemoService&methods=sayHello,sayHelloAsync&pid=32508&release=&side=provider&timestamp=1593253404714
        这个 Demo Provider 注册到 ZooKeeper 上的 URL 信息，简单解析一下这个 URL 的各个部分：
        protocol：dubbo 协议。
        username/password：没有用户名和密码。
        host/port：172.17.32.91:20880。
        path：org.apache.dubbo.demo.DemoService。
        parameters：参数键值对。

    源码位置: org.apache.dubbo.common.URL.URL(java.lang.String, java.lang.String, java.lang.String, java.lang.String, int, java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.util.Map<java.lang.String,java.util.Map<java.lang.String,java.lang.String>>)
        在 dubbo-common 包中还提供了 URL 的辅助类：
            URLBuilder: 辅助构造 URL。
            URLStrParser: 将字符串解析成 URL 对象。

    URL 在SPI中的应用
        Dubbo SPI 中有一个依赖 URL 的重要场景——适配器方法，是被 @Adaptive 注解标注的， URL 一个很重要的作用就是与 @Adaptive 注解一起选择合适的扩展实现类。
        例如: 在 dubbo-registry-api 模块中我们可以看到 RegistryFactory 这个接口，其中的 getRegistry() 方法上有 @Adaptive({"protocol"}) 注解，
             说明这是一个适配器方法，Dubbo 在运行时会为其动态生成相应的 “$Adaptive” 类型，如下所示:
             public class RegistryFactory$Adaptive
                           implements RegistryFactory {
                 public Registry getRegistry(org.apache.dubbo.common.URL arg0) {
                     if (arg0 == null) throw new IllegalArgumentException("...");
                     org.apache.dubbo.common.URL url = arg0;
                     // 尝试获取URL的Protocol，如果Protocol为空，则使用默认值"dubbo"
                     String extName = (url.getProtocol() == null ? "dubbo" :
                          url.getProtocol());
                     if (extName == null)
                         throw new IllegalStateException("...");
                     // 根据扩展名选择相应的扩展实现，Dubbo SPI的核心原理
                     RegistryFactory extension = (RegistryFactory) ExtensionLoader
                       .getExtensionLoader(RegistryFactory.class)
                             .getExtension(extName);
                     return extension.getRegistry(arg0);
                 }
             }
        我们会看到，在生成的 RegistryFactory$Adaptive 类中会自动实现 getRegistry() 方法，其中会根据 URL 的 Protocol 确定扩展名称，从而确定使用的具体扩展实现类。
        我们可以找到 RegistryProtocol 这个类，并在其 getRegistry() 方法中打一个断点， Debug 启动Demo 示例中的 Provider，得到如下图所示的内容：
            传入的值是URL中的registryUrl : service-discovery-registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.2&export=dubbo%3A%2F%2F192.168.0.91%3A20880%2Forg.apache.dubbo.demo.GreetingService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26bind.ip%3D192.168.0.91%26bind.port%3D20880%26deprecated%3Dfalse%26dubbo%3D2.0.2%26dynamic%3Dtrue%26generic%3Dfalse%26group%3Dgreeting%26interface%3Dorg.apache.dubbo.demo.GreetingService%26mapping-type%3Dmetadata%26mapping.type%3Dmetadata%26metadata-type%3Dremote%26methods%3Dhello%26pid%3D2417%26qos.port%3D22222%26release%3D%26revision%3D1.0.0%26side%3Dprovider%26timeout%3D5000%26timestamp%3D1600050456247%26version%3D1.0.0&id=registry1&mapping-type=metadata&mapping.type=metadata&pid=2417&qos.port=22222&registry=zookeeper&registry-type=service&timestamp=1600050456218
            通过URL获取的Registry中的registryUrl : zookeeper://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.2&id=registry1&interface=org.apache.dubbo.registry.RegistryService&mapping-type=metadata&mapping.type=metadata&pid=2417&qos.port=22222&registry-type=service&timestamp=1600050456218

    URL 在服务暴露中的应用
        Provider 在启动时，会将自身暴露的服务注册到 ZooKeeper 上，具体是注册哪些信息到 ZooKeeper 上呢？
        来看 ZookeeperRegistry.doRegister() 方法，在其中打个断点，然后 Debug 启动 Provider:
            url : dubbo://192.168.0.91:20880/org.apache.dubbo.demo.DemoService?anyhost=true&application=dubbo-demo-annotation-provider&deprecated=false&dubbo=2.0.2&dynamic=true&generic=false&interface=org.apache.dubbo.demo.DemoService&methods=sayHello,sayHelloAsync&pid=2579&release=&side=provider&timestamp=1600051163018
            toUrlPath(url) : /dubbo/org.apache.dubbo.demo.DemoService/providers/dubbo%3A%2F%2F192.168.0.91%3A20880%2Forg.apache.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddubbo-demo-annotation-provider%26deprecated%3Dfalse%26dubbo%3D2.0.2%26dynamic%3Dtrue%26generic%3Dfalse%26interface%3Dorg.apache.dubbo.demo.DemoService%26methods%3DsayHello%2CsayHelloAsync%26pid%3D2579%26release%3D%26side%3Dprovider%26timestamp%3D1600051163018
        传入的 URL 中包含了 Provider 的地址（192.168.0.91:20880）、暴露的接口（org.apache.dubbo.demo.DemoService）等信息， toUrlPath() 方法会根据传入的 URL 参数确定在 ZooKeeper 上创建的节点路径，还会通过 URL 中的 dynamic 参数值确定创建的 ZNode 是临时节点还是持久节点。

    URl 在服务订阅中的应用
        Consumer 启动后会向注册中心进行订阅操作，并监听自己关注的 Provider。那 Consumer 是如何告诉注册中心自己关注哪些 Provider 呢？
        我们来看 ZookeeperRegistry 这个实现类，它是由上面的 ZookeeperRegistryFactory 工厂类创建的 Registry 接口实现，
        其中的 doSubscribe() 方法是订阅操作的核心实现，在方法里面打一个断点，并 Debug 启动 Demo 中 Consumer，会得到下图所示的内容：
            传入的url : consumer://192.168.0.91/org.apache.dubbo.demo.DemoService?application=dubbo-demo-annotation-consumer&category=providers,configurators,routers&dubbo=2.0.2&id=org.apache.dubbo.config.RegistryConfig#0&init=false&interface=org.apache.dubbo.demo.DemoService&methods=sayHello,sayHelloAsync&pid=2654&side=consumer&sticky=false&timestamp=1600051729106
            其中 Protocol 为 consumer ，表示是 Consumer 的订阅协议，其中的 category 参数表示要订阅的分类，这里要订阅 providers、configurators 以及 routers 三个分类；interface 参数表示订阅哪个服务接口，这里要订阅的是暴露 org.apache.dubbo.demo.DemoService 实现的 Provider。
            toCategoriesPath(url) : 0 = "/dubbo/org.apache.dubbo.demo.DemoService/providers"
                                    1 = "/dubbo/org.apache.dubbo.demo.DemoService/configurators"
                                    2 = "/dubbo/org.apache.dubbo.demo.DemoService/routers"

4、: JDK SPI机制
    SPI 机制原理
        SPI（Service Provider Interface）主要是被框架开发人员使用的一种技术。
        例如，使用 Java 语言访问数据库时我们会使用到 java.sql.Driver 接口，不同数据库产品底层的协议不同，提供的 java.sql.Driver 实现也不同，
          在开发 java.sql.Driver 接口时，开发人员并不清楚用户最终会使用哪个数据库，在这种情况下就可以使用 Java SPI 机制在实际运行过程中，为 java.sql.Driver 接口寻找具体的实现。

    JDK SPI原理
        当服务的提供者提供了一种接口的实现之后，需要在 Classpath 下的 META-INF/services/ 目录里创建一个以服务接口命名的文件，此文件记录了该 jar 包提供的服务接口的具体实现类。
        当某个应用引入了该 jar 包且需要使用该服务时，JDK SPI 机制就可以通过查找这个 jar 包的 META-INF/services/ 中的配置文件来获得具体的实现类名，进行实现类的加载和实例化，最终使用该实现类完成业务功能。
        实例代码dubbo-demo/spi

    JDK SPI源码分析
        java.util.ServiceLoader.load(java.lang.Class<S>)
        ClassLoader(Thread.currentThread().getContextClassLoader())
            -> if(null) ClassLoader(ClassLoader.getSystemClassLoader())
                -> java.util.ServiceLoader.reload
                    // 用来存放ServiceLoader创建的对象
                    private LinkedHashMap<String,S> providers = new LinkedHashMap<>();
                    -> providers.clear() 清空缓存
                        -> lookupIterator = new LazyIterator(service, loader) 创建一个加载SPI的迭代器

        由java.util.ServiceLoader.LazyIterator.hasNextService去查询META-INF下面是否还存在接口实现
        由java.util.ServiceLoader.LazyIterator.nextService去创建该接口的实现

    JDK SPI机制在JDBC中的应用
        JDK 中只定义了一个 java.sql.Driver 接口，具体的实现是由不同数据库厂商来提供的。以 MySQL 提供的 JDBC 实现包为例进行分析。
        在 mysql-connector-java-*.jar 包中的 META-INF/services 目录下，有一个 java.sql.Driver 文件中只有一行内容，如下所示：
            com.mysql.cj.jdbc.Driver
        创建连接的语句如下:
            String url = "jdbc:xxx://xxx:xxx/xxx";
            Connection conn = DriverManager.getConnection(url, username, pwd);
        DriverManager 是JDK提供的驱动管理设备具体调用如下:
            java.sql.DriverManager#ensureDriversInitialized

5、Dubbo SPI机制
    SPI扩展点介绍:
        1、扩展点：通过 SPI 机制查找并加载实现的接口（又称“扩展接口”）。 Logger 接口、com.mysql.cj.jdbc.Driver 接口，都是扩展点。
        2、扩展点实现：实现了扩展接口的实现类。

        JDK SPI 在查找扩展实现类的过程中，需要遍历 SPI 配置文件中定义的所有实现类，该过程中会将这些实现类全部实例化。
    如果 SPI 配置文件中定义了多个实现类，而我们只需要使用其中一个实现类时，就会生成不必要的对象。
    例如，org.apache.dubbo.rpc.Protocol 接口有 InjvmProtocol、DubboProtocol、RmiProtocol、HttpProtocol、HessianProtocol、ThriftProtocol 等多个实现，如果使用 JDK SPI，就会加载全部实现类，导致资源的浪费。
    Dubbo SPI 不仅解决了上述资源浪费的问题，还对 SPI 配置文件扩展和修改。

    Dubbo 按照 SPI 配置文件的用途，将其分成了三类目录:
        1、META-INF/services/ 目录：该目录下的 SPI 配置文件用来兼容 JDK SPI 。
        2、META-INF/dubbo/ 目录：该目录用于存放用户自定义 SPI 配置文件。
        3、META-INF/dubbo/internal/ 目录：该目录用于存放 Dubbo 内部使用的 SPI 配置文件。
      Dubbo 将 SPI 配置文件改成了 KV 格式
        K : 扩展名称
        V : 扩展实现

    Dubbo @SPI 注解
        dubbo 中某个接口被标注了@SPI，就说明这个接口是一个扩展接口，如: org.apache.dubbo.rpc.Protocol。
        @SPI 注解的 value 值指定了默认的扩展名称，
        例如，在通过 Dubbo SPI 加载 Protocol 接口实现时，如果没有明确指定扩展名，则默认会将 @SPI 注解的 value 值作为扩展名，即加载 dubbo 这个扩展名对应的 org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol 这个扩展实现类，相关的 SPI 配置文件在 dubbo-rpc-dubbo 模块中
        那 ExtensionLoader 是如何处理 @SPI 注解的呢？
            org.apache.dubbo.common.extension.ExtensionLoader.getExtensionLoader
                -> org.apache.dubbo.common.extension.ExtensionLoader.withExtensionAnnotation
            ExtensionLoader 中三个核心的静态字段:
                1、strategies（LoadingStrategy[]类型）: LoadingStrategy 接口有三个实现（通过 JDK SPI 方式加载的），
                    如下所示，分别对应前面介绍的三个 Dubbo SPI 配置文件所在的目录，且都继承了 Prioritized 这个优先级接口，默认优先级是
                       DubboInternalLoadingStrategy > DubboLoadingStrategy > ServicesLoadingStrateg
                2、EXTENSION_LOADERS（ConcurrentMap<Class<?>, ExtensionLoader<?>>）: Dubbo 中一个扩展接口对应一个 ExtensionLoader 实例，
                    该集合缓存了全部 ExtensionLoader 实例，其中的 Key 为扩展接口，Value 为加载其扩展实现的 ExtensionLoader 实例。
                3、EXTENSION_INSTANCES（ConcurrentMap<Class<?>, Object>类型）：该集合缓存了扩展实现类与其实例对象的映射关系。
                    如: Key 为 Class，Value 为 DubboProtocol 对象。
            ExtensionLoader 中的其他字段:
                1、type（Class<?>类型）：当前 ExtensionLoader 实例负责加载扩展接口。
                2、cachedDefaultName（String类型）：记录了 type 这个扩展接口上 @SPI 注解的 value 值，也就是默认扩展名。
                3、cachedNames（ConcurrentMap<Class<?>, String>类型）：缓存了该 ExtensionLoader 加载的扩展实现类与扩展名之间的映射关系。
                4、cachedClasses（Holder<Map<String, Class<?>>>类型）：缓存了该 ExtensionLoader 加载的扩展名与扩展实现类之间的映射关系。cachedNames 集合的反向关系缓存。
                5、cachedInstances（ConcurrentMap<String, Holder<Object>>类型）：缓存了该 ExtensionLoader 加载的扩展名与扩展实现对象之间的映射关系。
        ExtensionLoader 核心方法:
            1、org.apache.dubbo.common.extension.ExtensionLoader.getExtensionLoader() 获取并创建指定类型的ExtensionLoader对象
            2、org.apache.dubbo.common.extension.ExtensionLoader.createExtension SPI 配置文件的查找以及相应扩展实现类的实例化，同时还实现了自动装配以及自动 Wrapper 包装等功能

    @Adaptive 注解与适配器
        @Adaptive 注解用来实现 Dubbo 的适配器功能，那什么是适配器呢？
            Dubbo 中的 ExtensionFactory 接口有三个实现类: SpiExtensionFactory、SpringExtensionFactory、AdaptiveExtensionFactory
            如下所示，ExtensionFactory 接口上有 @SPI 注解，AdaptiveExtensionFactory 实现类上有 @Adaptive 注解。
                @SPI
                ExtensionFactory
                                 ->  SpiExtensionFactory
                                 ->  SpringExtensionFactory
                                     @Adaptive
                                 ->  AdaptiveExtensionFactory
            AdaptiveExtensionFactory 不实现任何具体的功能，而是用来适配 ExtensionFactory 的 SpiExtensionFactory 和 SpringExtensionFactory 这两种实现。
            AdaptiveExtensionFactory 会根据运行时的一些状态来选择具体调用 ExtensionFactory 的哪个实现。

            @Adaptive 注解还可以加到接口方法之上，Dubbo 会动态生成适配器类。
            例如，Transporter 接口有两个被 @Adaptive 注解修饰的方法
                @Adaptive({Constants.SERVER_KEY, Constants.TRANSPORTER_KEY})
                RemotingServer bind(URL url, ChannelHandler handler) throws RemotingException;
                @Adaptive({Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY})
                Client connect(URL url, ChannelHandler handler) throws RemotingException;
            Dubbo 会生成一个 Transporter$Adaptive 适配器类，该类继承了 Transporter 接口：
                public class Transporter$Adaptive implements Transporter {
                    public org.apache.dubbo.remoting.Client connect(URL arg0, ChannelHandler arg1) throws RemotingException {
                        // 必须传递URL参数
                        if (arg0 == null) throw new IllegalArgumentException("url == null");
                        URL url = arg0;
                        // 确定扩展名，优先从URL中的client参数获取，其次是transporter参数
                        // 这两个参数名称由@Adaptive注解指定，最后是@SPI注解中的默认值
                        String extName = url.getParameter("client",
                            url.getParameter("transporter", "netty"));
                        if (extName == null)
                            throw new IllegalStateException("...");
                        // 通过ExtensionLoader加载Transporter接口的指定扩展实现
                        Transporter extension = (Transporter) ExtensionLoader
                              .getExtensionLoader(Transporter.class)
                                    .getExtension(extName);
                        return extension.connect(arg0, arg1);
                    }
                    ... // 省略bind()方法
                }
            生成 Transporter$Adaptive 这个类的逻辑位于 ExtensionLoader.createAdaptiveExtensionClass() 方法，其中涉及的 javassist 等方面的知识。
            ExtensionLoader.createExtension() 方法，其中在扫描 SPI 配置文件的时候，会调用 loadClass() 方法加载 SPI 配置文件中指定的类。
            loadClass() 方法中会识别加载扩展实现类上的 @Adaptive 注解，将该扩展实现的类型缓存到 cachedAdaptiveClass 这个实例字段上（volatile修饰）。

    自动包装特性
        Dubbo 中的一个扩展接口可能有多个扩展实现类，这些扩展实现类可能会包含一些相同的逻辑，如果在每个实现类中都写一遍，那么这些重复代码就会变得很难维护。
        Dubbo 提供的自动包装特性，就可以解决这个问题。 Dubbo 将多个扩展实现类的公共逻辑，抽象到 Wrapper 类中，
        Wrapper 类与普通的扩展实现类一样，也实现了扩展接口，在获取真正的扩展实现对象时，在其外面包装一层 Wrapper 对象，可以看成一层装饰器。
         代码: ExtensionLoader.loadClass()
             ...
             if (clazz.isAnnotationPresent(Adaptive.class)) {
                 cacheAdaptiveClass(clazz, overridden);
                 // 在 isWrapperClass() 方法中，会判断该扩展实现类是否包含拷贝构造函数（即构造函数只有一个参数且为扩展接口类型），
                 // 如果包含，则为 Wrapper 类，这就是判断 Wrapper 类的标准。
             } else if (isWrapperClass(clazz)) {
                 // 将 Wrapper 类记录到 cachedWrapperClasses（Set<Class<?>>类型）这个实例字段中进行缓存。
                 cacheWrapperClass(clazz);
             }
             ...

    自动装配特性
        在 ExtensionLoader.createExtension() 方法中我们看到，Dubbo SPI 在拿到扩展实现类的对象（以及 Wrapper 类的对象）之后，
        还会调用 injectExtension() 方法扫描其全部 setter 方法，并根据 setter 方法的名称以及参数的类型，加载相应的扩展实现，
        然后调用相应的 setter 方法填充属性，这就实现了 Dubbo SPI 的自动装配特性。简单来说，自动装配属性就是在加载一个扩展点的时候，将其依赖的扩展点一并加载，并进行装配。
        具体方法: ExtensionLoader.injectExtension()
            injectExtension() 方法实现的自动装配依赖了 ExtensionFactory（即 objectFactory 字段），
            ExtensionFactory 有 SpringExtensionFactory 和 SpiExtensionFactory 两个真正的实现（还有一个实现是 AdaptiveExtensionFactory 是适配器）。
            1、SpringExtensionFactory: 将属性名称作为 Spring Bean 的名称，从 Spring 容器中获取 Bean
            2、SpiExtensionFactory: 根据扩展接口获取相应的适配器，没有用到属性名称


     @Activate注解与自动激活特性
        以 Dubbo 中的 Filter 为例说明自动激活特性的含义，org.apache.dubbo.rpc.Filter 接口有非常多的扩展实现类，
        在一个场景中可能需要某几个 Filter 扩展实现类协同工作，而另一个场景中可能需要另外几个实现类一起工作。
        这样，就需要一套配置来指定当前场景中哪些 Filter 实现是可用的，这就是 @Activate 注解要做的事情。
        @Activate 注解标注在扩展实现类上，有 group、value 以及 order 三个属性。
            1、group 属性：修饰的实现类是在 Provider 端被激活还是在 Consumer 端被激活。
            2、value 属性：修饰的实现类只在 URL 参数中出现指定的 key 时才会被激活。
            3、order 属性：用来确定扩展实现类的排序。
        代码处理: ExtensionLoader.loadClass()
        使用地方: ExtensionLoader.getActivateExtension()
            首先，获取默认激活的扩展集合。默认激活的扩展实现类有几个条件：
                1、在 cachedActivates 集合中存在；
                2、@Activate 注解指定的 group 属性与当前 group 匹配；
                3、扩展名没有出现在 values 中（即未在配置中明确指定，也未在配置中明确指定删除）；
                4、URL 中出现了 @Activate 注解中指定的 Key。
            然后，按照 @Activate 注解中的 order 属性对默认激活的扩展集合进行排序。
            最后，按序添加自定义扩展实现类的对象。
          举例:
            扩展名称          @Activate中的group          @Activate中的order
            filter1            Provider                     6
            filter2            Provider                     5
            filter3            Provider                     4
            filter4            Provider                     3
            filter5            Consumer                     2
            filter6            Provider                     1
            在 Provider 端调用 getActivateExtension() 方法时传入的 values 配置为 "filter3、-filter2、default、filter1"，那么根据上面的逻辑：
            得到默认激活的扩展实实现集合中有 [ filter4, filter6 ]；
            排序后为 [ filter6, filter4 ]；
            按序添加自定义扩展实例之后得到 [ filter3, filter6, filter4, filter1 ]。

6、Dubbo中的定时任务
        JDK 提供的 java.util.Timer 和 DelayedQueue 等工具类，可以帮助我们实现简单的定时任务管理，其底层实现使用的是堆这种数据结构，存取操作的复杂度都是 O(nlog(n))，
    无法支持大量的定时任务。在定时任务量比较大、性能要求比较高的场景中，为了将定时任务的存取操作以及取消操作的时间复杂度降为 O(1)，一般会使用时间轮的方式。

    时间轮是一种高效的、批量管理定时任务的调度模型。
        时间轮一般会实现成一个环形结构，类似一个时钟，分为很多槽，一个槽代表一个时间间隔，每个槽使用双向链表存储定时任务；
        指针周期性地跳动，跳动到一个槽位，就执行该槽位的定时任务。

    需要注意的是，单层时间轮的容量和精度都是有限的，对于精度要求特别高、时间跨度特别大或是海量定时任务需要调度的场景，通常会使用多级时间轮以及持久化存储与时间轮结合的方案。

    dubbo实现timer位置: dubbo-common 模块的 org.apache.dubbo.common.timer 包
        核心接口:
            1、org.apache.dubbo.common.timer.Timer
            2、org.apache.dubbo.common.timer.TimerTask
            3、org.apache.dubbo.common.timer.Timeout
        具体实现类:
            HashedWheelTimer
        分析时间轮指针一次转动的全流程(HashedWheelTimer$Worker.run()):
            1、时间轮指针转动，时间轮周期开始。
            2、清理用户主动取消的定时任务，这些定时任务在用户取消时，会记录到 cancelledTimeouts 队列中。在每次指针转动的时候，时间轮都会清理该队列。
            3、将缓存在 timeouts 队列中的定时任务转移到时间轮中对应的槽中。
            4、根据当前指针定位对应槽，处理该槽位的双向链表中的定时任务。
            5、检测时间轮的状态。如果时间轮处于运行状态，则循环执行上述步骤，不断执行定时任务。
                如果时间轮处于停止状态，则执行下面的步骤获取到未被执行的定时任务并加入 unprocessedTimeouts 队列：遍历时间轮中每个槽位，
                并调用 clearTimeouts() 方法；对 timeouts 队列中未被加入槽中循环调用 poll()。
            6、最后再次清理 cancelledTimeouts 队列中用户主动取消的定时任务。

    dubbo中如何使用定时任务?
            在 Dubbo 中，时间轮并不直接用于周期性操作，而是只向时间轮提交执行单次的定时任务，在上一次任务执行完成的时候，调用 newTimeout() 方法再次提交当前任务，
        这样就会在下个周期执行该任务。即使在任务执行过程中出现了 GC、I/O 阻塞等情况，导致任务延迟或卡住，也不会有同样的任务源源不断地提交进来，导致任务堆积。
        Dubbo 中对时间轮的应用主要体现在如下两个方面：
            1、失败重试， 例如，Provider 向注册中心进行注册失败时的重试操作，或是 Consumer 向注册中心订阅时的失败重试等。
            2、周期性定时任务， 例如，定期发送心跳请求，请求超时的处理，或是网络连接断开后的重连机制。

7、dubbo注册模块（dubbo-registry）
    Dubbo 目前支持 Consul、etcd、Nacos、ZooKeeper、Redis 等多种开源组件作为注册中心，并且在 Dubbo 源码也有相应的接入模块。

    Dubbo 官方推荐使用 ZooKeeper 作为注册中心: ZkClient,Apache Curator 是实践中最常用的 ZooKeeper 客户端，dubbo 使用Apache Curator作为客户端。

    Apache ZooKeeper 是一个针对分布式系统的、可靠的、可扩展的协调服务，它通常作为统一命名服务、统一配置管理、注册中心（分布式集群管理）、分布式锁服务、Leader 选举服务等角色出现。
    很多分布式系统都依赖与 ZooKeeper 集群实现分布式系统间的协调调度，例如：Dubbo、HDFS 2.x、HBase、Kafka 等。ZooKeeper 已经成为现代分布式系统的标配。

    Apache Curator 是 Apache 基金会提供的一款 ZooKeeper 客户端，它提供了一套易用性和可读性非常强的 Fluent 风格的客户端 API ，可以帮助我们快速搭建稳定可靠的 ZooKeeper 客户端程序。































