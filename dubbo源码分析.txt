第一步: 构建源码调试环境
    dubbo源码官方地址: https://github.com/apache/dubbo
        1、fork 官方dubbo仓库到自己的仓库
        2、git clone git@github.com:[自己仓库名称]/dubbo.git
        3、到当前clone的目录(含有pom.xml)中，执行mvn clean install -Dmaven.test.skip=true
        4、将项目转换成idea项目 mvn idea:idea(如果需要失败可以利用 mvn idea:workspace)
        5、切换分支到目前主流分支
            git fetch   拉去所有相关的远程仓储到本地仓储
            git checkout -b 2.7.8-release  切换到release分支
第二步: 项目结构概览
    dubbo-common :  Dubbo 的一个公共模块，其中有很多工具类以及公共逻辑，例如 Dubbo SPI 实现、时间轮实现、动态编译器等。
        org.apache.dubbo.common.compiler : 动态编译相关
        org.apache.dubbo.common.config : 配置相关
        org.apache.dubbo.common.constants : 通用常量定义(如url参数的key)
        org.apache.dubbo.common.convert : 类型转换器
        org.apache.dubbo.common.extension : SPI 核心实现
        org.apache.dubbo.common.io : IO相关实现类
        org.apache.dubbo.common.logger : 多种java日志集成
        org.apache.dubbo.common.threadlocal : ThreadLocal相关工具类
        org.apache.dubbo.common.threadpool : 线程池相关工具类
        org.apache.dubbo.common.timer : 时间轮训器工具
        org.apache.dubbo.common.utils : 通用工具类
    dubbo-remoting : Dubbo 的远程通信模块，其中的子模块依赖各种开源组件实现远程通信。
        在 dubbo-remoting-api 子模块中定义该模块的抽象概念，在其他子模块中依赖其他开源组件进行实现，
        例如:
            dubbo-remoting-netty4 子模块依赖 Netty 4 实现远程通信，
            dubbo-remoting-etcd3 子模块依赖 etcd 3 实现远程通信，
            dubbo-remoting-p2p 子模块依赖 p2p 实现远程通信，
            dubbo-remoting-redis 子模块依赖 redis 实现远程通信，
            dubbo-remoting-zookeeper 通过 Apache Curator 实现与 ZooKeeper 集群的交互。
    dubbo-rpc : Dubbo 中对远程调用协议进行抽象的模块，其中抽象了各种协议，依赖于 dubbo-remoting 模块的远程调用功能。
        dubbo-rpc-api 子模块是核心抽象，其他子模块是针对具体协议的实现。
        例如:
            dubbo-rpc-dubbo 子模块是对 Dubbo 协议的实现，依赖了 dubbo-remoting-netty4 等 dubbo-remoting 子模块。
            dubbo-rpc 模块的实现中只包含一对一的调用，不关心集群的相关内容。
    dubbo-cluster :  Dubbo 中负责管理集群的模块，提供了负载均衡、容错、路由等一系列集群相关的功能，
        最终的目的是将多个 Provider 伪装为一个 Provider，这样 Consumer 就可以像调用一个 Provider 那样调用 Provider 集群了。
    dubbo-registry : Dubbo 中负责与多种开源注册中心进行交互的模块，提供注册中心的能力。
        其中， dubbo-registry-api 子模块是顶层抽象，其他子模块是针对具体开源注册中心组件的具体实现，
        例如，dubbo-registry-zookeeper 子模块是 Dubbo 接入 ZooKeeper 的具体实现。
    dubbo-monitor : Dubbo 的监控模块，主要用于统计服务调用次数、调用时间以及实现调用链跟踪的服务。
    dubbo-config :  Dubbo 对外暴露的配置都是由该模块进行解析的。
        例如:
        dubbo-config-api 子模块负责处理 API 方式使用时的相关配置
        dubbo-config-spring 子模块负责处理与 Spring 集成使用时的相关配置方式。
        有了 dubbo-config 模块，用户只需要了解 Dubbo 配置的规则即可，无须了解 Dubbo 内部的细节。
    dubbo-metadata : Dubbo 的元数据模块。
        dubbo-metadata 模块的实现套路也是有一个 api 子模块进行抽象，然后其他子模块进行具体实现。
    dubbo-configcenter : Dubbo 的动态配置模块，主要负责外部化配置以及服务治理规则的存储与通知，提供了多个子模块用来接入多种开源的服务发现组件。

第三步: 解析Dubbo配置总线 URL（Uniform Resource Locator，统一资源定位符）
    URL 本质上就是一个特殊格式的字符串。一个标准的 URL 格式可以包含如下的几个部分：
        protocol://username:password@host:port/path?key=value&key=value
        1、 protocol：URL 的协议。我们常见的就是 HTTP 协议和 HTTPS 协议，当然，还有其他协议，如 FTP 协议、SMTP 协议等。
        2、username/password：用户名/密码。 HTTP Basic Authentication 中多会使用在 URL 的协议之后直接携带用户名和密码的方式。
        3、host/port：主机/端口。在实践中一般会使用域名，而不是使用具体的 host 和 port。
        4、path：请求的路径。
        5、parameters：参数键值对。一般在 GET 请求中会将参数放到 URL 中，POST 请求会将参数放到请求体中。

    Dubbo中的URL : dubbo://192.168.32.91:20880/org.apache.dubbo.demo.DemoService?anyhost=true&application=dubbo-demo-api-provider&dubbo=2.0.2&interface=org.apache.dubbo.demo.DemoService&methods=sayHello,sayHelloAsync&pid=32508&release=&side=provider&timestamp=1593253404714dubbo://172.17.32.91:20880/org.apache.dubbo.demo.DemoService?anyhost=true&application=dubbo-demo-api-provider&dubbo=2.0.2&interface=org.apache.dubbo.demo.DemoService&methods=sayHello,sayHelloAsync&pid=32508&release=&side=provider&timestamp=1593253404714
        这个 Demo Provider 注册到 ZooKeeper 上的 URL 信息，简单解析一下这个 URL 的各个部分：
        protocol：dubbo 协议。
        username/password：没有用户名和密码。
        host/port：172.17.32.91:20880。
        path：org.apache.dubbo.demo.DemoService。
        parameters：参数键值对。

    源码位置: org.apache.dubbo.common.URL.URL(java.lang.String, java.lang.String, java.lang.String, java.lang.String, int, java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.util.Map<java.lang.String,java.util.Map<java.lang.String,java.lang.String>>)
        在 dubbo-common 包中还提供了 URL 的辅助类：
            URLBuilder: 辅助构造 URL。
            URLStrParser: 将字符串解析成 URL 对象。

    URL 在SPI中的应用
        Dubbo SPI 中有一个依赖 URL 的重要场景——适配器方法，是被 @Adaptive 注解标注的， URL 一个很重要的作用就是与 @Adaptive 注解一起选择合适的扩展实现类。
        例如: 在 dubbo-registry-api 模块中我们可以看到 RegistryFactory 这个接口，其中的 getRegistry() 方法上有 @Adaptive({"protocol"}) 注解，
             说明这是一个适配器方法，Dubbo 在运行时会为其动态生成相应的 “$Adaptive” 类型，如下所示:
             public class RegistryFactory$Adaptive
                           implements RegistryFactory {
                 public Registry getRegistry(org.apache.dubbo.common.URL arg0) {
                     if (arg0 == null) throw new IllegalArgumentException("...");
                     org.apache.dubbo.common.URL url = arg0;
                     // 尝试获取URL的Protocol，如果Protocol为空，则使用默认值"dubbo"
                     String extName = (url.getProtocol() == null ? "dubbo" :
                          url.getProtocol());
                     if (extName == null)
                         throw new IllegalStateException("...");
                     // 根据扩展名选择相应的扩展实现，Dubbo SPI的核心原理
                     RegistryFactory extension = (RegistryFactory) ExtensionLoader
                       .getExtensionLoader(RegistryFactory.class)
                             .getExtension(extName);
                     return extension.getRegistry(arg0);
                 }
             }
        我们会看到，在生成的 RegistryFactory$Adaptive 类中会自动实现 getRegistry() 方法，其中会根据 URL 的 Protocol 确定扩展名称，从而确定使用的具体扩展实现类。
        我们可以找到 RegistryProtocol 这个类，并在其 getRegistry() 方法中打一个断点， Debug 启动Demo 示例中的 Provider，得到如下图所示的内容：
            传入的值是URL中的registryUrl : service-discovery-registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.2&export=dubbo%3A%2F%2F192.168.0.91%3A20880%2Forg.apache.dubbo.demo.GreetingService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26bind.ip%3D192.168.0.91%26bind.port%3D20880%26deprecated%3Dfalse%26dubbo%3D2.0.2%26dynamic%3Dtrue%26generic%3Dfalse%26group%3Dgreeting%26interface%3Dorg.apache.dubbo.demo.GreetingService%26mapping-type%3Dmetadata%26mapping.type%3Dmetadata%26metadata-type%3Dremote%26methods%3Dhello%26pid%3D2417%26qos.port%3D22222%26release%3D%26revision%3D1.0.0%26side%3Dprovider%26timeout%3D5000%26timestamp%3D1600050456247%26version%3D1.0.0&id=registry1&mapping-type=metadata&mapping.type=metadata&pid=2417&qos.port=22222&registry=zookeeper&registry-type=service&timestamp=1600050456218
            通过URL获取的Registry中的registryUrl : zookeeper://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=demo-provider&dubbo=2.0.2&id=registry1&interface=org.apache.dubbo.registry.RegistryService&mapping-type=metadata&mapping.type=metadata&pid=2417&qos.port=22222&registry-type=service&timestamp=1600050456218

    URL 在服务暴露中的应用
        Provider 在启动时，会将自身暴露的服务注册到 ZooKeeper 上，具体是注册哪些信息到 ZooKeeper 上呢？
        来看 ZookeeperRegistry.doRegister() 方法，在其中打个断点，然后 Debug 启动 Provider:
            url : dubbo://192.168.0.91:20880/org.apache.dubbo.demo.DemoService?anyhost=true&application=dubbo-demo-annotation-provider&deprecated=false&dubbo=2.0.2&dynamic=true&generic=false&interface=org.apache.dubbo.demo.DemoService&methods=sayHello,sayHelloAsync&pid=2579&release=&side=provider&timestamp=1600051163018
            toUrlPath(url) : /dubbo/org.apache.dubbo.demo.DemoService/providers/dubbo%3A%2F%2F192.168.0.91%3A20880%2Forg.apache.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddubbo-demo-annotation-provider%26deprecated%3Dfalse%26dubbo%3D2.0.2%26dynamic%3Dtrue%26generic%3Dfalse%26interface%3Dorg.apache.dubbo.demo.DemoService%26methods%3DsayHello%2CsayHelloAsync%26pid%3D2579%26release%3D%26side%3Dprovider%26timestamp%3D1600051163018
        传入的 URL 中包含了 Provider 的地址（192.168.0.91:20880）、暴露的接口（org.apache.dubbo.demo.DemoService）等信息， toUrlPath() 方法会根据传入的 URL 参数确定在 ZooKeeper 上创建的节点路径，还会通过 URL 中的 dynamic 参数值确定创建的 ZNode 是临时节点还是持久节点。

    URl 在服务订阅中的应用
        Consumer 启动后会向注册中心进行订阅操作，并监听自己关注的 Provider。那 Consumer 是如何告诉注册中心自己关注哪些 Provider 呢？
        我们来看 ZookeeperRegistry 这个实现类，它是由上面的 ZookeeperRegistryFactory 工厂类创建的 Registry 接口实现，
        其中的 doSubscribe() 方法是订阅操作的核心实现，在方法里面打一个断点，并 Debug 启动 Demo 中 Consumer，会得到下图所示的内容：
            传入的url : consumer://192.168.0.91/org.apache.dubbo.demo.DemoService?application=dubbo-demo-annotation-consumer&category=providers,configurators,routers&dubbo=2.0.2&id=org.apache.dubbo.config.RegistryConfig#0&init=false&interface=org.apache.dubbo.demo.DemoService&methods=sayHello,sayHelloAsync&pid=2654&side=consumer&sticky=false&timestamp=1600051729106
            其中 Protocol 为 consumer ，表示是 Consumer 的订阅协议，其中的 category 参数表示要订阅的分类，这里要订阅 providers、configurators 以及 routers 三个分类；interface 参数表示订阅哪个服务接口，这里要订阅的是暴露 org.apache.dubbo.demo.DemoService 实现的 Provider。
            toCategoriesPath(url) : 0 = "/dubbo/org.apache.dubbo.demo.DemoService/providers"
                                    1 = "/dubbo/org.apache.dubbo.demo.DemoService/configurators"
                                    2 = "/dubbo/org.apache.dubbo.demo.DemoService/routers"

第四步: SPI机制
    SPI 机制原理
        SPI（Service Provider Interface）主要是被框架开发人员使用的一种技术。
        例如，使用 Java 语言访问数据库时我们会使用到 java.sql.Driver 接口，不同数据库产品底层的协议不同，提供的 java.sql.Driver 实现也不同，
          在开发 java.sql.Driver 接口时，开发人员并不清楚用户最终会使用哪个数据库，在这种情况下就可以使用 Java SPI 机制在实际运行过程中，为 java.sql.Driver 接口寻找具体的实现。

    JDK SPI原理
        当服务的提供者提供了一种接口的实现之后，需要在 Classpath 下的 META-INF/services/ 目录里创建一个以服务接口命名的文件，此文件记录了该 jar 包提供的服务接口的具体实现类。
        当某个应用引入了该 jar 包且需要使用该服务时，JDK SPI 机制就可以通过查找这个 jar 包的 META-INF/services/ 中的配置文件来获得具体的实现类名，进行实现类的加载和实例化，最终使用该实现类完成业务功能。
        实例代码dubbo-demo/spi

    JDK SPI源码分析
        java.util.ServiceLoader.load(java.lang.Class<S>)
        ClassLoader(Thread.currentThread().getContextClassLoader())
            -> if(null) ClassLoader(ClassLoader.getSystemClassLoader())
                -> java.util.ServiceLoader.reload
                    // 用来存放ServiceLoader创建的对象
                    private LinkedHashMap<String,S> providers = new LinkedHashMap<>();
                    -> providers.clear() 清空缓存
                        -> lookupIterator = new LazyIterator(service, loader) 创建一个加载SPI的迭代器

        由java.util.ServiceLoader.LazyIterator.hasNextService去查询META-INF下面是否还存在接口实现
        由java.util.ServiceLoader.LazyIterator.nextService去创建该接口的实现

    JDK SPI机制在JDBC中的应用
        JDK 中只定义了一个 java.sql.Driver 接口，具体的实现是由不同数据库厂商来提供的。以 MySQL 提供的 JDBC 实现包为例进行分析。
        在 mysql-connector-java-*.jar 包中的 META-INF/services 目录下，有一个 java.sql.Driver 文件中只有一行内容，如下所示：
            com.mysql.cj.jdbc.Driver
        创建连接的语句如下:
            String url = "jdbc:xxx://xxx:xxx/xxx";
            Connection conn = DriverManager.getConnection(url, username, pwd);
        DriverManager 是JDK提供的驱动管理设备具体调用如下:
            java.sql.DriverManager#ensureDriversInitialized













